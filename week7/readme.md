gcc에서 -c 옵션은 컴파일만 하고 링크는 하지 않음 (.o 오브젝트 파일 생성)

ctrl + alt + del면 지금 뭐가 실행되는지 알 수 있다.

# 프로세스

- 현재 실행중인 프로그램을 프로세스라고 한다.

## PID

프로세스 번호 Pid

## 프로세스의 종류

## 폰노이만의 store

필요한 파일을 주기억 장치에 저장

주기억 장치 rom

제일 먼저 실행되는 프로세스는 뭔가?

모든 프로세스의 부모는 누구인가?

모든 파일은 root 폴더에서 시작

---

프로그램은 쉘(명령어 처리기)가 실행한다.

return 0 가 쉘(셀?)이 받는다.

---

# ps : 프로세스 상태 보기

$ ps [-옵션]
현재 시스템 내에 존재하는 프로세스들의 실행 상태를 요약해서 출력한다.

# pgrep : 특정 프로세스만 리스트

$ pgrep [옵션] [패턴]
패턴에 해당하는 프로세스들만을 리스트 한다.
-l : PID와 함께 프로세스의 이름을 출력한다.
-f : 명령어의 경로도 출력한다.
-n : 패턴과 일치하는 프로세스들 중에서 가장 최근 프로세스만을 출력한다.
-x : 패턴과 정확하게 일치되는 프로세스만 출력한다.
-a : 전체 명령어 줄과 PID를 출력한다.

---

# 쉘

return 0받는것

프로그램 실행하는 것

ps쳤을때 bash가 보이는데

이게 쉘이다.

---

# 후면처리

- 뒤에서 실행하는것
- & 엔터퍼센트?

$ 명령어 &
[1] 프로세스번호

$ sleep 10 &
[1] 6530
$ ps
PID TTY TIME CMD
1519 pts/0 00:00:00 bash
6530 pts/0 00:00:00 sleep
6535 pts/0 00:00:00 ps

그냥 sleep 10을 하면 프롬프트가 사라지고 sleep이 10동안 진행된다.

그러나 뒤에 &를 붙이는것으로 후면 처리기로 보낼 수 있다.

---

# 강제 종료

- 강제종료 Ctrl-C
$ 명령어
^C
    - 예시
    $ (sleep 100; echo DONE)
    ^C
    $
- 실행 (잠시) 정지 Ctrl-Z
$ 명령어
^Z
[1]+ 정지됨 명령어

---

## fg : 후면 → 전면 작업 변환

$ fg
정지된 작업을 다시 전면에서 실행시킨다.

## bg : 전면 → 후면

## kill : 프로세스 강제 종료

$ kill 프로세스번호
$ kill %작업번호
프로세스 번호(혹은 작업 번호)에 해당하는 프로세스를 강제로 종료시킨다.

## wait : 프로세스 기다리기

$ wait [프로세스번호]
프로세스 번호로 지정한 자식 프로세스가 종료될 때까지 기다린다.
지정하지 않으면 모든 자식 프로세스가 끝나기를 기다린다

## nice : 우선순위 변경

$ nice [-n 조정수치] 명령어 [인수들]
주어진 명령을 조정된 우선순위로 실행한다.

## renice :프로세스 우선순위 조정

$ renice [-n] 우선순위 [-gpu] PID
이미 수행중인 프로세스의 우선순위를 명시된 우선순위로 변경한다.
-g : 해당 그룹명 소유로 된 프로세스를 의미한다.
-u : 지정한 사용자명의 소유로 된 프로세스를 의미한다.
-p : 해당 프로세스의 PID를 지정한다.

---

# id : 프로세스의 사용자

$ id [사용자명]
사용자의 실제 ID와 유효 사용자 ID, 그룹 ID 등을 보여준다.

프로세스 실행자의 id

## 실제 사용자 id

## 유효 사용자 id

특별한 실행파일을 실행할 때 유효 사용자 ID는 달라진다. 

# set - user - id

### 유효 사용자 ID는 그 실행파일의 소유자로 바뀜

무슨뜻이냐

원래 실행파일의 권환은 root가 가지고 있다.

그래서 너도 쓸 수 있게 해줄게 → 유효사용자

실소유자는 root인것

유효 사용자 id는 내가 아니라 → 실제론 root거지만 쓸 수 있게 해준것

---

# 주요 시그널


## kill 명령어

---

# 핵심개념

- 프로세스는 실행중인 프로그램이다.
- 각 프로세스는 프로세스 ID를 갖는다. 각 프로세스는 부모 프로세스
에 의해 생성된다.
 쉘은 사용자와 운영체제 사이에 창구 역할을 하는 소프트웨어로 사
용자로부터 명령어를 입력받아 이를 처리하는 명령어 처리기 역할을
한다.
 전면 처리는 명령어가 전면에서 실행되므로 쉘이 명령어 실행이 끝
나기를 기다리지만 후면 처리는 명령어가 후면에서 실행되므로 쉘이
명령어 실행이 끝나기를 기다리지 않는다.
 각 프로세스는 실제 사용자 ID와 유효 사용자 ID를 갖는다.
 시그널은 예기치 않은 사건이 발생할 때 이를 알리는 소프트웨어 인
터럽트이다.
 kill 명령어를 이용하여 특정 프로세스에 원하는 시그널을 보낼 수 있
다.

---


ll = ls -alF 대신 쓰는것

컨트롤 브레이크와 컨트롤 c 둘다 중단명령어

ctrl +c 가 안먹히면 브레이크 쓸것

---

# 파일 실행하면 반드시 실행되는 3가지

복습

- 입력
- 출력
- 에러메세지

---

# wsl에서 password 잊었다면

cmd 연다

wsl —u root 친다.

password<username>을 친다.

새로운 비밀번호를 2번 친다.

wsl에서만 가능하다.

