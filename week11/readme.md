
심볼릭 링크인 e.txt가 업로드 되지 않는다.

---

리눅스는 ext 파일 시스템

이중간접, 삼중간접 가능

하나의 블록 inode가 40개 정도 있다.

inode내에 접근권한, 생성날짜같은 각종 정보가 있다.

- 한파일은 하나의 inode를 갖는다.

open , use, close 기억

fd = 파일 디스크립터

오픈할때마다 할당

dup로 할당된것을 변경가능

dup는 시스템 콜

같은 파일을 다른 번호로 쓸 수 있다.

stat()은 struct = 구조체로 되어 있다.

chmod(), fchmod()

- 파일의 접근권한 변경

utime() = touch 명령과 같다.

- 접근 및 수정 시간 변경
- utime()만들걸 이용해서 touch도 만들기?
- uname도 만들어볼까

chown()

- 파일 소유자 변경

디렉토리

- opendir()
- readdir()

파일 이름과 크기 출력

- 원랜 바이트를 만들어줌

st_mode 

디렉터리 삭제

- rmdir

디렉토리 구현

블록 번호 = 주소

201번에 ls와 cp가 있다

디렉토리의 현재정보와 부모정보만 있다면 디렉토리 관리가 가능하다.

하드링크

- 파일 시스템 내의 i-노드를 가리키므로 같은 파일 시스템 내에서만 사용될 수 있다.

심볼릭 링크

- 실제 파일의 경로명

# 시스템 명령어와 사용자가 만든 명령어가 같다면 어떻게 차이를 보이나

시스템 경로(path)

근데 이름이 같으면 뭐가 더 우선순위를 가지지

# 리뷰 끝

## ln과 copy의 차이

| 명령어 | 목적 | 독립성 | 파일 시스템 제약 | 원본 삭제 시 |
| --- | --- | --- | --- | --- |
| `cp` | 복사 | 완전 독립 | 없음 | 영향 없음 |
| `ln` | 하드 링크 | 동일 파일 참조 | 같은 파일 시스템 | 영향 없음 |

b와 c는 ln

d는 cp로 a.txt를 복사했다.

왼쪽 숫자는 하드링크 수

b나 c중 하나를 지우면, 하드링크 수가 바뀐다.(줄어든다)

## link()

몇번째 i-node인지 나타낸다.


```c
#include <unistd.h>
int main(int argc, char *argv[ ])
{
if (link(argv[1], argv[2]) == -1) {
exit(1);
}
exit(0);
}

이게 ln 명령어
```

## 심볼릭 링크, ln - s

심볼릭 링크는 원본이 삭제되면 쓰레기가 된다.

링크패스만 있으니까

하드링크는 i-node를 공유함으로 상관없다.

# ch 7 -07아님

빠르게 넘어감

## 파일 레코드 잠금의 원리

### lock

- 한 프로세스가 파일에 쓴 내용을 다른 프로세스가 읽음 - 문제
- 한 프로세스가 그 영역을 읽거나 수정할 때 다른 프로세스의 접근을 제한한다.
- 잠금된 영역에 한 번에 하나의 프로세스만 접근

그냥 화장실처럼 생각할것

## flock()

파일 전체에 잠금

잠금도 어느정도로 할지 범위가 설정 가능하다

## fcntl() 잠금 함수

이하 넘어감

읽어 볼것

# 권고 잠금과 강제 잠금

권고 잠금은 말 그대로 잠금을 할 수 있지만 강제되지는 않음

강제 잠금

잠금은

- 잠금된 파일을 굳이 건드리지 말자고 서로 약속하는것
- 문제는 잠긴 파일을 쓰려고 하면 쓸 수 있다.

# ch 8

## 쉘

control + d가 종료인것을 알아둘것

명령 프롬프트에선 ctrl+z다

## 전면처리 후면처리

후면처리하려면 뒤에 &만 붙이면 된다.

## 프로세스

실행중인 프로그램이다.

각각의 프로세스는 ‘유일한’ 번호를 얻는다 = pid

ps로 현재 존재하는 프로세스들의 실행상태를 요약해서 출력한다.

프로그램을 실행시키는것은 **운영체제**이다.

ps -auf(BSD 유닉스 = 무료 유닉스)

kill

- 현재 실행중인 프로세스를 강제로 종료

wait - sleep과 다른점은?

프로세스 제어가 가능하다.

exit

- 쉘을 종료하고 종료코드(exit code)를 부모 프로세스에 전달
- 근데 쉘이 항상 부모가 아닌건가?

# 지금 실행중인 프로그램(프로세스) 누가 실행 시켰어?

- 어떤 프로세스든 다른 프로세스에 의해 실행될 수 있다.
- 프로세스 A가 프로세스 B를 실행시킨다면 부모 프로세스
- 프로세스 A의 부모는 쉘

# 프로그램 실행 시작

exec 시스템 호출 - 프로그램 실행

c 시작 루틴 - main 함수를 호출하며서 명령줄 인수, 환경 변수를 전달

# 명령줄 인수/ 환경 변수

```c
int main(int argc, char *argv[]);
argc : 명령줄 인수의 개수
argv[] : 명령줄 인수 리스트를 나타내는 포인터 배열
```

![image.png](attachment:3663b89b-407c-436c-9c6d-e7e97f7721d8:image.png)

extern - 외부에 있는걸 쓰려고 할때 사용하는 c언어

## 환경변수설정

putenv(), setent()를 사용하여 특정 환경 변수를 설정

- 매개변수에 따라 차이가 있다?

# 프로그램 종료

- 정상 종료 - exit()호출
- 비정상 종료 -  abort

exit()

- 모든 열려진 스트림을 닫고(fclose) 출력 버퍼의 내용을 디스크에
쓰는(fflush) 등의 뒷정리 후 프로세스를 정상적으로 종료
- 종료 코드(exit code)를 부모 프로세스에게 전달한다.

exit가 알아서 닫아줘서 close를 쓰지 않아도 되지만, 쓰는 습관을 들여라

_exit()는 닫지 않고 프로세스를 즉시 종료한다.

![image.png](attachment:e3ea220e-05bf-4ee9-97c8-e7c39b49d4a7:image.png)

exit를 만나면, 이것저것 다 처리하고 kernel로 간다.

_exit를 만나면 바로 kernel로 가서 종료

---

## atexit()

```c
#include <stdlib.h>

void atexit(void (*func)(void));
returns: 0 if OK, nonzero on error
```

*func = 함수 포인터

exit 처리기를 등록한다

- 32개까지 가

## 프로세스 id

모든 프로세스는 부모를 가진다.

최상위 프로세스는?

 **init 프로세스** 또는 systemd

프로세스 id외에

사용자 id와 그룹 id를 갖는다.

### 실제 사용자와 유효 사용자

### set-user-id

- 특별한 실행권한 set-user-id(set user ID upon execution)
 set-user-id 설정된 실행파일을 실행하면
 이 프로세스의 유효 사용자 ID는 그 실행파일의 소유자로 바뀜.
 이 프로세스는 실행되는 동안 그 파일의 소유자 권한을 갖게 됨.
- 예 : /bin/passwd 명령어
(1) set-user-id 실행권한이 설정된 실행파일이며 소유자는 root
(2) 일반 사용자가 이 파일을 실행하면 이 프로세스의 유효 사용자 ID
는 root가 됨.
$ /bin/passwd
(3) /etc/shadow처럼 root만 수정할 수 있는 파일의 접근 및 수정 가능

root만 사용할 수 있는 명령어지만, 너무 많이 문의해서 권한을 이양했다.

원래 권력이 많다는것은 할일이 많다는것

$ ls –asl /bin/su /usr/bin/passwd
32 -rwsr-xr-x. 1 root root 32396 2011-05-31 01:50 /bin/su
28 -rwsr-xr-x. 1 root root 27000 2010-08-22 12:00 /usr/bin/passwd

여기서 ‘s’가 심볼릭모드 - rnjsgksdmf qkedkTeksmsrjt

set-user-id 실행권한 설정
$ chmod 4755 file1

그룹id는 숫자에 2를 붙인다.

$ chmod 2755 file1

## pid.c - 프로세스 번호 출력

```c
printf("나의 프로세스 번호 : [%d] \n", getpid());
printf("내 부모 프로세스 번호 : [%d] \n", getppid());
```

# 프로세스

프로세스 = 실행중인 프로그램

프로그램 실행을 위해서는 

- 프로그램의 코드(텍스트), 데이터, 스택, 힙, U-영역 등이 필요하다.

 

프로그램 자체가 프로세스는 아니다!!!

![image.png](attachment:993a503c-3327-43fe-ad18-e4272ff99fb6:image.png)

변수가 데이터, 힙, 스택에 들어가는것이 각각 다르다.

![image.png](attachment:55b2c3d2-27ec-4cc0-bf50-91bbadcb32f7:image.png)

우리가 그냥 int i 했다면 , stack에 있다.

static으로 선언하거나 전역변수로 하면 data

U-영역은 검색에서 잘 안나옴

Rect rect = new Rect();

에서 rect는 객체이면서 참조변수 → 스택에 있다.

Rect는 힙에 있다.

자세히 말해,  Rect라는 멤버 데이터나 기타 필요한 정보는 힙에 저장된다.

rect는 그 힙의 저장된 장소를 참조하는 주소이기에 스택에 있다.

그렇기에 스택 오버 플로우처럼 힙 오버플로우도 존재한다.

잘 못 볼 뿐

### ✅ 객체는 어디에 만들어질까?

```java
java
복사편집
class Dog {
    String name;
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog(); // 여기서 객체 생성!
    }
}

```

- `new Dog()` → **힙 영역**에 `Dog` 객체가 생성됨
- `d` → 스택 영역에 저장되는 참조 변수. `d`는 힙에 있는 객체를 가리킴

class의 인스턴스가 객체(object)

클래스의 인스턴스는 **클래스를 기반으로 실제로 만들어진 객체**

쉽게 말하면, **클래스는 설계도**고, **인스턴스는 그 설계도로 만든 실체**

# ch 9

init. systemd → pid1번

근데 그럼 쉘도 프로그램인가 → 그렇다

# 프로세스 생성

## fork()

자기복제

이걸로 다른일을 하는 프로세스를 호출하거나 만들 수 있다.
